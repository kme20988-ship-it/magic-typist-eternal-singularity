[{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/App.jsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n  126 |       setTimeout(() => setShowLevelUpEffect(true), 0);\n  127 |       audioManager.playSFX('levelup');\n> 128 |       triggerDialogue(\"Âäõ„Åå...ÈÄ≤Âåñ„Åó„Åü„ÅûÔºÅ\");\n      |       ^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  129 |       setTimeout(() => setShowLevelUpEffect(false), 2000);\n  130 |       prevDragonLevel.current = dragonLevel;\n  131 |     }","line":128,"column":7,"nodeType":null,"endLine":128,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react';\nimport { Swords, RotateCcw, HelpCircle, Map } from 'lucide-react';\nimport BattleScreen from './components/BattleScreen';\nimport MagicKeyboard from './components/MagicKeyboard';\nimport MoneyDisplay from './components/MoneyDisplay';\nimport ResultScreen from './components/ResultScreen';\nimport SplashScreen from './components/SplashScreen';\nimport ChantBreakOverlay from './components/ChantBreakOverlay';\nimport InteractiveTutorial from './components/InteractiveTutorial';\nimport { useIdleIncome } from './hooks/useIdleIncome';\nimport { gameConfig, generateSpell } from './utils/gameConfig';\nimport { unitData } from './data/unitData';\nimport raidData from './data/raidData.json';\nimport { canRebirth } from './utils/rebirthSystem';\nimport HomeScreen from './components/HomeScreen';\nimport ObjectiveBanner from './components/ObjectiveBanner';\nimport CyberpunkBackground from './components/CyberpunkBackground';\nimport audioManager from './utils/AudioManager';\nimport { ACHIEVEMENT_LIST } from './data/achievementData';\nimport AchievementToast from './components/AchievementToast';\nimport AchievementList from './components/AchievementList';\nimport CriticalHit from './components/CriticalHit';\n\n\n// Wasm Integration\nimport init, {\n  calculate_upgrade_cost,\n  calculate_idle_income,\n  calculate_damage,\n  calculate_reward,\n  calculate_rebirth_orbs,\n  calculate_monster_hp\n} from \"./wasm_pkg/magic_engine\";\n\nimport SettingsMenu from './components/SettingsMenu';\nimport LoreTerminal from './components/LoreTerminal';\nimport ArtifactScreen from './components/ArtifactScreen';\nimport SkillTree from './components/SkillTree';\nimport MagicSelectionModal from './components/MagicSelectionModal';\nimport WorldSelectionModal from './components/WorldSelectionModal';\n\n\nfunction App() {\n  const [wasmReady, setWasmReady] = useState(false);\n\n  useEffect(() => {\n    init().then(() => setWasmReady(true));\n    audioManager.init();\n  }, []);\n\n  const [money, setMoney] = useState(0);\n  const [totalEarned, setTotalEarned] = useState(0);\n  const [combo, setCombo] = useState(0);\n  const [maxCombo, setMaxCombo] = useState(0);\n  const [currentScene, setCurrentScene] = useState('home');\n\n  const [upgrades, setUpgrades] = useState(gameConfig.upgrades.map(u => ({ ...u, level: 0 })));\n  const [settings, setSettings] = useState({ haptic: true, particle: true, music: 50, sfx: 50 });\n  const [collectedUnits, setCollectedUnits] = useState(['n_egg']);\n  const [unitLevels, setUnitLevels] = useState({ 'n_egg': 1 });\n  const [spiritOrbs, setSpiritOrbs] = useState(0);\n  const [artifacts, setArtifacts] = useState([]);\n  const [unlockedSkills, setUnlockedSkills] = useState([]);\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [isHaptic, setIsHaptic] = useState(false);\n  const [showResult, setShowResult] = useState(false);\n  const [showSplash, setShowSplash] = useState(true);\n  const [unlockedAchievements, setUnlockedAchievements] = useState([]);\n  const [activeAchievementToast, setActiveAchievementToast] = useState(null);\n  const [showAchievementList, setShowAchievementList] = useState(false);\n  const [showCriticalOverlay, setShowCriticalOverlay] = useState(false);\n\n  // Sync settings with AudioManager\n  useEffect(() => {\n    audioManager.setEnabled(settings.sound);\n    audioManager.setVolume(settings.music / 100);\n  }, [settings.sound, settings.music]);\n  const [activeTutorial, setActiveTutorial] = useState(null);\n  const [completedTutorials, setCompletedTutorials] = useState([]);\n  const [showSettings, setShowSettings] = useState(false);\n  const [showLore, setShowLore] = useState(false);\n  const [showArtifacts, setShowArtifacts] = useState(false);\n  const [showSkills, setShowSkills] = useState(false);\n  const [showMagicSelection, setShowMagicSelection] = useState(false);\n  const [showWorldSelection, setShowWorldSelection] = useState(false);\n  const [isVictorious, setIsVictorious] = useState(false);\n\n  // Manual Burst System (Formerly Chant Break)\n  const [chantBreakGauge, setChantBreakGauge] = useState(0);\n  const [isManualBurst, setIsManualBurst] = useState(false);\n  const [dragonLevel, setDragonLevel] = useState(1);\n  const [familiarDialogue, setFamiliarDialogue] = useState(\"\");\n  const tapTimestamps = useRef([]);\n\n  // Magic Battle State\n  const [currentSpell, setCurrentSpell] = useState([]);\n  const [currentProgress, setCurrentProgress] = useState(0);\n  const [monsterHealth, setMonsterHealth] = useState(100);\n  const [monsterElement, setMonsterElement] = useState('FIRE');\n  const [stageIndex, setStageIndex] = useState(0);\n  const [monsterMaxHealth, setMonsterMaxHealth] = useState(100);\n  const [totalTaps, setTotalTaps] = useState(0);\n  const [correctTaps, setCorrectTaps] = useState(0);\n  const [currentBossName, setCurrentBossName] = useState(null);\n  const [lastDamage, setLastDamage] = useState(0);\n  const [unlockedElements, setUnlockedElements] = useState(['FIRE', 'WATER']);\n  const [equippedElements, setEquippedElements] = useState(['FIRE', 'WATER']);\n  const [currentWorldId, setCurrentWorldId] = useState('GENESIS');\n  const [worldProgress, setWorldProgress] = useState({ GENESIS: 0, CYBERIA: 0, ETERNITY: 0, LEGEND: 0 });\n\n  const comboResetTimer = useRef(null);\n  const [offlineEarnings, setOfflineEarnings] = useState(0);\n\n  // Trigger dialogue helper\n  const triggerDialogue = useCallback((text) => {\n    setFamiliarDialogue(text);\n    setTimeout(() => setFamiliarDialogue(\"\"), 3000);\n  }, []);\n\n  const [showLevelUpEffect, setShowLevelUpEffect] = useState(false);\n  const prevDragonLevel = useRef(dragonLevel);\n\n  useEffect(() => {\n    if (dragonLevel > prevDragonLevel.current) {\n      // Use setTimeout to avoid synchronous setState warning\n      setTimeout(() => setShowLevelUpEffect(true), 0);\n      audioManager.playSFX('levelup');\n      triggerDialogue(\"Âäõ„Åå...ÈÄ≤Âåñ„Åó„Åü„ÅûÔºÅ\");\n      setTimeout(() => setShowLevelUpEffect(false), 2000);\n      prevDragonLevel.current = dragonLevel;\n    }\n  }, [dragonLevel, triggerDialogue]);\n\n  // Load state\n  useEffect(() => {\n    if (!wasmReady) return;\n    const saved = {\n      money: localStorage.getItem('magic_idle_money'),\n      total: localStorage.getItem('magic_idle_total'),\n      upgrades: localStorage.getItem('magic_idle_upgrades'),\n      maxCombo: localStorage.getItem('magic_idle_maxCombo'),\n      tutorialCompleted: localStorage.getItem('magic_idle_tutorial_completed'),\n      completedTutorials: localStorage.getItem('magic_idle_completedTutorials'),\n      settings: localStorage.getItem('magic_idle_settings'),\n      collectedUnits: localStorage.getItem('magic_idle_collectedUnits'),\n      unitLevels: localStorage.getItem('magic_idle_unitLevels'),\n      spiritOrbs: localStorage.getItem('magic_idle_spiritOrbs'),\n      artifacts: localStorage.getItem('magic_idle_artifacts'),\n      stageIndex: localStorage.getItem('magic_idle_stageIndex'),\n      skills: localStorage.getItem('magic_idle_skills'),\n      unlockedElements: localStorage.getItem('magic_idle_unlockedElements'),\n      equippedElements: localStorage.getItem('magic_idle_equippedElements'),\n      currentWorldId: localStorage.getItem('magic_idle_currentWorldId'),\n      worldProgress: localStorage.getItem('magic_idle_worldProgress')\n    };\n\n    // Wrap updates in setTimeout to avoid sync render warnings\n    setTimeout(() => {\n      if (saved.money) setMoney(parseFloat(saved.money));\n      if (saved.total) setTotalEarned(parseFloat(saved.total));\n      if (saved.maxCombo) setMaxCombo(parseInt(saved.maxCombo));\n      if (saved.stageIndex) setStageIndex(parseInt(saved.stageIndex));\n      if (saved.spiritOrbs) setSpiritOrbs(parseInt(saved.spiritOrbs));\n      if (saved.skills) setUnlockedSkills(JSON.parse(saved.skills));\n      if (saved.unitLevels) setUnitLevels(JSON.parse(saved.unitLevels));\n      if (saved.collectedUnits) setCollectedUnits(JSON.parse(saved.collectedUnits));\n      if (saved.settings) setSettings(JSON.parse(saved.settings));\n      if (saved.artifacts) setArtifacts(JSON.parse(saved.artifacts));\n      if (saved.currentWorldId) setCurrentWorldId(saved.currentWorldId);\n      if (localStorage.getItem('magic_idle_achievements')) {\n        setUnlockedAchievements(JSON.parse(localStorage.getItem('magic_idle_achievements')));\n      }\n      if (saved.worldProgress) {\n        let parsedProgress = JSON.parse(saved.worldProgress);\n        // Legacy Migration\n        if (parsedProgress.EARTH !== undefined) {\n          parsedProgress.GENESIS = parsedProgress.EARTH;\n          delete parsedProgress.EARTH;\n        }\n        if (parsedProgress.FUTURE !== undefined) {\n          parsedProgress.CYBERIA = parsedProgress.FUTURE;\n          delete parsedProgress.FUTURE;\n        }\n        if (parsedProgress.COSMOS !== undefined) {\n          parsedProgress.ETERNITY = parsedProgress.COSMOS;\n          delete parsedProgress.COSMOS;\n        }\n        if (saved.currentWorldId === 'EARTH') setCurrentWorldId('GENESIS');\n        if (saved.currentWorldId === 'FUTURE') setCurrentWorldId('CYBERIA');\n        if (saved.currentWorldId === 'COSMOS') setCurrentWorldId('ETERNITY');\n\n        setWorldProgress(parsedProgress);\n      }\n\n      const loadedStage = saved.stageIndex ? parseInt(saved.stageIndex) : 0;\n      const worldId = saved.currentWorldId === 'EARTH' ? 'GENESIS' :\n        (saved.currentWorldId === 'FUTURE' ? 'CYBERIA' :\n          (saved.currentWorldId === 'COSMOS' ? 'ETERNITY' : (saved.currentWorldId || 'GENESIS')));\n      const worldData = gameConfig.worlds.find(w => w.id === worldId);\n      const initialMaxHp = calculate_monster_hp(100.0 * worldData.hpScale, 1.8, loadedStage, loadedStage % 10 === 0 && loadedStage > 0);\n      setMonsterMaxHealth(initialMaxHp);\n      setMonsterHealth(initialMaxHp);\n\n      // Calculate Offline Earnings\n      const lastLogin = localStorage.getItem('magic_idle_lastLogin');\n      if (lastLogin && saved.money && saved.upgrades) {\n        const now = Date.now();\n        const diffSeconds = Math.floor((now - parseInt(lastLogin)) / 1000);\n        if (diffSeconds > 60) {\n          const currentUpgrades = JSON.parse(saved.upgrades);\n          const baseIncome = currentUpgrades.reduce((total, up) => {\n            return total + calculate_idle_income(up.baseIncome, up.level);\n          }, 0);\n          const earned = baseIncome * diffSeconds * 0.8;\n          if (earned > 0) {\n            setOfflineEarnings(earned);\n            setMoney(prev => prev + earned);\n            setTotalEarned(prev => prev + earned);\n          }\n        }\n      }\n\n\n      if (saved.completedTutorials) {\n        setCompletedTutorials(JSON.parse(saved.completedTutorials));\n      } else if (saved.tutorialCompleted) {\n        setCompletedTutorials(['INTRO']); // Migration for old players\n      }\n\n      if (!saved.tutorialCompleted && !showSplash) {\n        setActiveTutorial('INTRO');\n      }\n\n      // Load unlocked elements or default to FIRE/WATER\n      const loadedElements = saved.unlockedElements ? JSON.parse(saved.unlockedElements) : ['FIRE', 'WATER'];\n      setUnlockedElements(loadedElements);\n      setUnlockedElements(loadedElements);\n\n      if (saved.equippedElements) {\n        setEquippedElements(JSON.parse(saved.equippedElements));\n      } else {\n        setEquippedElements(loadedElements.slice(0, 6));\n      }\n\n      setCurrentSpell(generateSpell(4, saved.equippedElements ? JSON.parse(saved.equippedElements) : loadedElements.slice(0, 6)));\n      setIsLoaded(true);\n    }, 0);\n  }, [showSplash, wasmReady]);\n\n  // Save state\n  useEffect(() => {\n    if (!isLoaded) return;\n    localStorage.setItem('magic_idle_money', money.toString());\n    localStorage.setItem('magic_idle_total', totalEarned.toString());\n    localStorage.setItem('magic_idle_upgrades', JSON.stringify(upgrades));\n    localStorage.setItem('magic_idle_maxCombo', maxCombo.toString());\n    localStorage.setItem('magic_idle_skills', JSON.stringify(unlockedSkills));\n    localStorage.setItem('magic_idle_settings', JSON.stringify(settings));\n    localStorage.setItem('magic_idle_collectedUnits', JSON.stringify(collectedUnits));\n    localStorage.setItem('magic_idle_unitLevels', JSON.stringify(unitLevels));\n    localStorage.setItem('magic_idle_spiritOrbs', spiritOrbs.toString());\n    localStorage.setItem('magic_idle_artifacts', JSON.stringify(artifacts));\n    localStorage.setItem('magic_idle_stageIndex', stageIndex.toString());\n    localStorage.setItem('magic_idle_lastLogin', Date.now().toString());\n    localStorage.setItem('magic_idle_equippedElements', JSON.stringify(equippedElements));\n    localStorage.setItem('magic_idle_currentWorldId', currentWorldId);\n    localStorage.setItem('magic_idle_worldProgress', JSON.stringify(worldProgress));\n    localStorage.setItem('worldProgress', JSON.stringify(worldProgress));\n    localStorage.setItem('magic_idle_completedTutorials', JSON.stringify(completedTutorials));\n    localStorage.setItem('magic_idle_achievements', JSON.stringify(unlockedAchievements));\n  }, [money, totalEarned, upgrades, maxCombo, unlockedSkills, settings, collectedUnits, unitLevels, spiritOrbs, artifacts, stageIndex, isLoaded, unlockedElements, equippedElements, currentWorldId, worldProgress, completedTutorials, unlockedAchievements]);\n\n  // BGM Switching\n  useEffect(() => {\n    if (showSplash) return;\n    if (currentScene === 'battle') {\n      audioManager.playBGM('battle');\n    } else {\n      audioManager.playBGM('home');\n    }\n  }, [currentScene, showSplash]);\n\n\n  const magicStats = useMemo(() => {\n    const equippedObjs = gameConfig.attributes.filter(a => equippedElements.includes(a.id));\n    return {\n      atk: equippedObjs.reduce((sum, a) => sum + (a.stats?.atk || 0), 0) / 6,\n      spd: equippedObjs.reduce((sum, a) => sum + (a.stats?.spd || 0), 0) / 6,\n      crit: equippedObjs.reduce((sum, a) => sum + (a.stats?.crit || 0), 0) / 6\n    };\n  }, [equippedElements]);\n\n  // Deck Power Calculation\n  const deckStats = useMemo(() => {\n    let attack = 0;\n    let income = 0;\n    collectedUnits.forEach(unitId => {\n      const unit = unitData.find(u => u.id === unitId);\n      const level = unitLevels[unitId] || 1;\n      if (unit) {\n        const multiplier = 1 + (0.5 * (level - 1));\n        attack += unit.stats.attack * multiplier;\n        income += unit.stats.speed * multiplier;\n      }\n    });\n    return { attack, income };\n  }, [collectedUnits, unitLevels]);\n\n  // Artifact Bonus Calculation\n  const artifactStats = useMemo(() => {\n    let damageMult = 1;\n    let incomeMult = 1;\n    let comboTime = 0;\n    artifacts.forEach(a => {\n      if (a.id === 'gold_keyboard') damageMult += (0.5 * a.level);\n      if (a.id === 'greed_wallet') incomeMult += (0.2 * a.level);\n      if (a.id === 'time_stopper') comboTime += (500 * a.level);\n    });\n    return { damageMult, incomeMult, comboTime };\n  }, [artifacts]);\n\n  const idleTotal = wasmReady ? upgrades.reduce((total, upgrade) => {\n    return total + calculate_idle_income(upgrade.baseIncome, upgrade.level);\n  }, 0) : 0;\n  const idleIncome = (idleTotal + deckStats.income) * artifactStats.incomeMult;\n\n  const handleIdleIncome = useCallback((income) => {\n    setMoney(p => p + income);\n    setTotalEarned(p => p + income);\n  }, []);\n  useIdleIncome(idleIncome, handleIdleIncome);\n\n  // Objective Logic\n  const currentObjective = useMemo(() => {\n    if (showSplash) return null;\n\n    // 1. Initial State\n    if (stageIndex === 0 && currentScene === 'home') {\n      return { text: \"Êà¶„ÅÆÊ∫ñÂÇô„ÇíÊï¥„Åà„Çà„ÄÇ\", type: 'FIGHT', actionId: 'fight-button' };\n    }\n\n    // 2. Rebirth Recommendation\n    const rebirthOrbs = calculate_rebirth_orbs(totalEarned, 1000000.0, 1000000.0);\n    if (rebirthOrbs >= 10 && currentScene === 'home') {\n      return { text: \"Áßò„ÇÅ„Åü„ÇãÈ≠Ç„ÇíËß£Êîæ„Åó„ÄÅÊñ∞„Åü„Å™È´ò„Åø„Å∏Ëª¢Áîü„Åõ„Çà„ÄÇ\", type: 'REBIRTH', actionId: 'rebirth-button' };\n    }\n\n    // 3. Upgrade Recommendation\n    const nextUpgrade = upgrades.find(u => money >= calculate_upgrade_cost(u.baseCost, u.costMultiplier, u.level));\n    if (nextUpgrade && currentScene === 'home') {\n      return { text: \"È≠îÂ∞éÂÖ∑„ÇíÂº∑Âåñ„Åó„ÄÅÂäõ„ÇíËìÑ„Åà„Çã„ÅÆ„Å†„ÄÇ\", type: 'UPGRADE', actionId: 'shop-tab' };\n    }\n    if (nextUpgrade && currentScene === 'battle') {\n      return { text: \"‰∏ÄÂ∫¶ÈÄÄ„Åç„ÄÅÊà¶Âäõ„ÇíÁ´ã„Å¶Áõ¥„Åô„Åπ„Åç„Å†„Çç„ÅÜ„ÄÇ\", type: 'UPGRADE', actionId: 'back-to-home' };\n    }\n\n    // 4. Combat Status\n    if (currentScene === 'battle') {\n      if (monsterHealth / monsterMaxHealth > 0.8 && combo < 10) {\n        return { text: \"Ë©†Âî±„ÇíÊÄ•„ÅíÔºÅÂÖâ„ÇíÂàª„ÅøËæº„ÇÄ„ÅÆ„Å†„ÄÇ\", type: 'FIGHT', actionId: 'magic-keyboard' };\n      }\n      return { text: \"„Åù„ÅÆË™øÂ≠ê„Å†„ÄÇ„Ç∞„É™„ÉÉ„ÉÅ„ÅÆ„Ç≥„Ç¢„ÇíË≤´„ÅëÔºÅ\", type: 'FIGHT', actionId: null };\n    }\n\n    // Default\n    return { text: \"Ê∑±Ê∑µ„ÅÆË™øÊüª„ÇíÂÜçÈñã„Åô„Çã„Åû„ÄÇ\", type: 'FIGHT', actionId: 'fight-button' };\n  }, [money, totalEarned, stageIndex, currentScene, upgrades, showSplash, monsterHealth, monsterMaxHealth, combo]);\n\n  const handleMagicInput = useCallback((attrId) => {\n    setTotalTaps(prev => prev + 1);\n    const now = Date.now();\n    tapTimestamps.current.push(now);\n    if (tapTimestamps.current.length > 10) tapTimestamps.current.shift();\n    const recentTaps = tapTimestamps.current.filter(t => now - t < 1000);\n    const tapsPerSecond = recentTaps.length;\n    const isRapidTap = tapsPerSecond >= 5;\n    const isElementMatch = attrId === monsterElement;\n\n    // Critical Hit logic (Visual part)\n    if (Math.random() < 0.02 && !showCriticalOverlay) {\n      setShowCriticalOverlay(true);\n      triggerDialogue(\"„É™„Éü„ÉÉ„Éà„Éñ„É¨„Ç§„Ç´„ÉºÂßãÂãï...„ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Éª„Éè„ÉÉ„ÇØÔºÅ\");\n    }\n\n    if (attrId === currentSpell[currentProgress]) {\n      audioManager.playSFX('click');\n      setCorrectTaps(prev => prev + 1);\n      const nextProgress = currentProgress + 1;\n      if (settings.haptic) {\n        setIsHaptic(true);\n        setTimeout(() => setIsHaptic(false), 100);\n      }\n\n      const hasSurge = unlockedSkills.includes('mana_surge');\n      if (!isManualBurst) {\n        setChantBreakGauge(prev => {\n          const spdBonus = 1 + (magicStats.spd / 10);\n          const gain = (isRapidTap ? 5 : 2) * (hasSurge ? 2 : 1) * spdBonus;\n          const newGauge = Math.min(prev + gain, 100);\n          if (newGauge >= 100) {\n            setIsManualBurst(true);\n            triggerDialogue(\"„Éû„Éã„É•„Ç¢„É´„Éª„Éê„Éº„Çπ„ÉàÔºÅÈÄ£ÊíÉ„ÇíÂè©„ÅçËæº„ÇÅÔºÅ\");\n            setTimeout(() => {\n              setIsManualBurst(false);\n              setChantBreakGauge(0);\n            }, 3000);\n          }\n          return newGauge;\n        });\n      }\n\n      if (nextProgress === currentSpell.length) {\n        const isFever = combo >= gameConfig.feverTriggerCombo;\n        let multiplier = isFever ? gameConfig.feverMultiplier : 1;\n        if (isManualBurst) multiplier *= 3;\n        if (isRapidTap) multiplier *= 1.5;\n\n        // Intensity Density: Factor in Magic Stats ATK\n        multiplier *= (1 + (magicStats.atk / 10));\n\n        const hasCrit = unlockedSkills.includes('crit_master');\n        const critSource = hasCrit ? 0.2 : 0.05;\n        const totalCritChance = critSource + (magicStats.crit / 100);\n        const isCrit = Math.random() < totalCritChance;\n        if (isCrit) {\n          multiplier *= 2;\n          triggerDialogue(\"‰ºöÂøÉ„ÅÆ‰∏ÄÊíÉ„Å†ÔºÅ\");\n        }\n\n        const worldData = gameConfig.worlds.find(w => w.id === currentWorldId);\n        const reward = calculate_reward(\n          gameConfig.baseTypingReward * worldData.rewardScale,\n          combo,\n          gameConfig.comboMultiplier,\n          multiplier\n        );\n        setMoney(p => p + reward);\n        setTotalEarned(p => {\n          const newTotal = p + reward;\n          setDragonLevel(Math.floor(newTotal / 1000) + 1);\n          return newTotal;\n        });\n        setCombo(p => {\n          const newCombo = p + 1;\n          if (newCombo > maxCombo) setMaxCombo(newCombo);\n          if (newCombo % 10 === 0) triggerDialogue(`${newCombo} „Ç≥„É≥„ÉúÔºÅÂÆü„Å´Ë¶ã‰∫ã„Å†„ÄÇ`);\n          return newCombo;\n        });\n\n        setMonsterHealth(prev => {\n          // worldData unused\n          const totalDmg = calculate_damage(\n            20.0,\n            deckStats.attack,\n            isElementMatch,\n            isRapidTap,\n            artifactStats.damageMult,\n            multiplier\n          );\n          setLastDamage(totalDmg);\n          audioManager.playSFX('hit');\n\n          // World Mechanics: ETERNITY Gravity\n          let damageToApply = totalDmg;\n          if (currentWorldId === 'ETERNITY') {\n            damageToApply *= 0.5;\n          }\n          if (currentWorldId === 'LEGEND') {\n            damageToApply *= 0.3; // Even more penalty for Legend\n          }\n\n          const next = prev - damageToApply;\n          if (next <= 0 && !isVictorious) {\n            setIsVictorious(true);\n            audioManager.playSFX('defeat');\n            setTimeout(() => {\n              triggerDialogue(\"Êïµ„ÇíÂ±†„Å£„Åü„ÄÇÊ¨°„Å™„ÇãÊ®ôÁöÑ„Å∏„ÄÇ\");\n              const attrs = gameConfig.attributes;\n              setMonsterElement(attrs[Math.floor(Math.random() * attrs.length)].id);\n\n              const nextIdx = stageIndex + 1;\n              setStageIndex(nextIdx);\n              setWorldProgress(prevProgress => ({ ...prevProgress, [currentWorldId]: nextIdx }));\n\n              // Check for Raid Boss\n              const isBossStage = nextIdx % 10 === 0;\n              let newMaxHp;\n              let bossName = null;\n\n              if (isBossStage) {\n                // Find a boss based on Tier (approx 1 tier per 50 stages) or loop\n                const tier = Math.min(4, Math.floor(nextIdx / 50) + 1);\n                const availableBosses = raidData.raidBosses.filter(b => b.tier === tier);\n                const boss = availableBosses.length > 0\n                  ? availableBosses[nextIdx % availableBosses.length]\n                  : raidData.raidBosses[0];\n\n                newMaxHp = boss.health * (1 + (nextIdx * 0.1)); // Scale boss HP\n                bossName = boss.name;\n                triggerDialogue(`Ë≠¶Âëä: ${boss.name} „ÅåÂá∫ÁèæÔºÅ`);\n              } else {\n                const worldData = gameConfig.worlds.find(w => w.id === currentWorldId);\n                newMaxHp = calculate_monster_hp(100.0 * worldData.hpScale, 1.8, nextIdx, false);\n                bossName = null;\n              }\n\n              setCurrentBossName(bossName);\n              setMonsterMaxHealth(newMaxHp);\n              setMonsterHealth(newMaxHp);\n              setIsVictorious(false);\n            }, 1200);\n            return 0;\n          }\n          return next;\n        });\n\n        setCurrentSpell(generateSpell(Math.min(8, 3 + Math.floor(combo / 10)), equippedElements));\n        setCurrentProgress(0);\n      } else {\n        setCurrentProgress(nextProgress);\n      }\n\n      if (comboResetTimer.current) clearTimeout(comboResetTimer.current);\n      const hasTimeBend = unlockedSkills.includes('time_bend');\n      const resetTime = 4000 + artifactStats.comboTime + (hasTimeBend ? 1000 : 0);\n      comboResetTimer.current = setTimeout(() => {\n        setCombo(0);\n        if (combo > 10) triggerDialogue(\"ÈõÜ‰∏≠Âäõ„ÅåÂàá„Çå„Åü„Åã...\");\n      }, resetTime);\n    } else {\n      audioManager.playSFX('error');\n      const hasShield = unlockedSkills.includes('combo_shield');\n      if (hasShield && !localStorage.getItem('combo_shield_used')) {\n        localStorage.setItem('combo_shield_used', 'true');\n        triggerDialogue(\"ÂÆàË≠∑„ÅÆÈ¢®„Å†„ÄÇ‰∏ª„ÇíÂÆà„ÇäÂàá„Å£„Åü„Åã„ÄÇ\");\n        setCurrentProgress(0);\n      } else {\n        setCombo(0);\n        setCurrentProgress(0);\n      }\n    }\n  }, [currentSpell, currentProgress, combo, maxCombo, isManualBurst, deckStats, artifactStats, monsterElement, settings.haptic, unlockedSkills, triggerDialogue, stageIndex, equippedElements, magicStats, currentWorldId, isVictorious, showCriticalOverlay]);\n\n  // Keyboard Mapping\n  const KEY_MAPPING = useMemo(() => ['q', 'w', 'e', 'r', 't', 'y'], []);\n\n  useEffect(() => {\n    const handleKeyDown = (e) => {\n      if (currentScene !== 'battle' || isManualBurst || isVictorious) return;\n      const key = e.key.toLowerCase();\n      const index = KEY_MAPPING.indexOf(key);\n      if (index !== -1 && index < equippedElements.length) {\n        handleMagicInput(equippedElements[index]);\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [currentScene, isManualBurst, isVictorious, equippedElements, handleMagicInput, KEY_MAPPING]);\n\n  // Progressive Unlock System (Ultra Density Edition)\n  useEffect(() => {\n    const milestones = [\n      { s: 3, id: 'THUNDER' }, { s: 10, id: 'WIND' }, { s: 20, id: 'LIGHT' }, { s: 30, id: 'DARK' },\n      { s: 40, id: 'ICE' }, { s: 50, id: 'EARTH' }, { s: 60, id: 'TOXIC' }, { s: 70, id: 'GRAVITY' },\n      { s: 80, id: 'SOUL' }, { s: 90, id: 'METAL' }, { s: 100, id: 'BLOOD' }, { s: 120, id: 'TIME' },\n      { s: 140, id: 'SPACE' }, { s: 160, id: 'NATURE' }, { s: 180, id: 'STORM' }, { s: 200, id: 'STAR' },\n      { s: 220, id: 'HOLY' }, { s: 250, id: 'CHAOS' }, { s: 270, id: 'MAGMA' }, { s: 290, id: 'STEAM' },\n      { s: 310, id: 'PLASMA' }, { s: 330, id: 'QUAKE' }, { s: 350, id: 'ZERO' }, { s: 370, id: 'AURA' },\n      { s: 390, id: 'MIRROR' }, { s: 410, id: 'ECHO' }, { s: 430, id: 'ABYSS' }, { s: 450, id: 'ZENITH' },\n      { s: 470, id: 'PULSE' }, { s: 490, id: 'DRAGON' }, { s: 510, id: 'FEATHER' }, { s: 530, id: 'PETAL' },\n      { s: 550, id: 'BONE' }, { s: 570, id: 'GEAR' }, { s: 590, id: 'NEON' }, { s: 610, id: 'PIXEL' },\n      { s: 630, id: 'VIRUS' }, { s: 650, id: 'CORE' }\n    ];\n\n    milestones.forEach(m => {\n      if (stageIndex >= m.s - 1 && !unlockedElements.includes(m.id)) {\n        setUnlockedElements(prev => [...prev, m.id]);\n        const attr = gameConfig.attributes.find(a => a.id === m.id);\n        triggerDialogue(`Êñ∞„Åó„ÅÑÂ±ûÊÄß„Äê${attr.name}„Äë„ÅÆÁêÜ„ÇíÁêÜËß£„Åó„Åü„Çà„ÅÜ„Å†„Å™„ÄÇ`);\n      }\n    });\n  }, [stageIndex, unlockedElements, triggerDialogue]);\n\n  useEffect(() => {\n    if (currentProgress === 0) localStorage.removeItem('combo_shield_used');\n  }, [currentProgress]);\n\n  const handleSkillUnlock = useCallback((skillId, cost) => {\n    if (money >= cost) {\n      setMoney(prev => prev - cost);\n      setUnlockedSkills(prev => [...prev, skillId]);\n    }\n  }, [money]);\n\n  const handlePurchase = useCallback((upgradeId) => {\n    setUpgrades(prev => {\n      const upgradeIndex = prev.findIndex(u => u.id === upgradeId);\n      const upgrade = prev[upgradeIndex];\n      const cost = calculate_upgrade_cost(upgrade.baseCost, upgrade.costMultiplier, upgrade.level);\n      if (money >= cost) {\n        setMoney(currentMoney => currentMoney - cost);\n        audioManager.playSFX('levelup');\n        const newUpgrades = [...prev];\n        newUpgrades[upgradeIndex] = { ...newUpgrades[upgradeIndex], level: newUpgrades[upgradeIndex].level + 1 };\n        return newUpgrades;\n      }\n      return prev;\n    });\n  }, [money]);\n\n  const handlePullGacha = useCallback((newUnit) => {\n    setCollectedUnits(prev => prev.includes(newUnit.id) ? prev : [...prev, newUnit.id]);\n    setUnitLevels(prev => ({ ...prev, [newUnit.id]: (prev[newUnit.id] || 0) + 1 }));\n  }, []);\n\n  const handleSpentMoney = useCallback((amount) => setMoney(prev => Math.max(0, prev - amount)), []);\n\n  // Achievement Check Logic\n  useEffect(() => {\n    if (!isLoaded) return;\n    const gameState = {\n      stageIndex,\n      maxCombo,\n      totalEarned,\n      collectedUnits,\n      dragonLevel,\n      worldProgress,\n      totalTaps\n    };\n\n    ACHIEVEMENT_LIST.forEach(ach => {\n      if (!unlockedAchievements.includes(ach.id) && ach.condition(gameState)) {\n        setUnlockedAchievements(prev => [...prev, ach.id]);\n        setActiveAchievementToast(ach);\n        audioManager.playSFX('gacha'); // Reuse gacha sound for achievement\n      }\n    });\n  }, [stageIndex, maxCombo, totalEarned, collectedUnits, dragonLevel, worldProgress, totalTaps, unlockedAchievements, isLoaded]);\n\n  const handleRebirth = useCallback(() => {\n    const orbs = calculate_rebirth_orbs(totalEarned, 1000000.0, 1000000.0);\n    if (orbs > 0) {\n      setSpiritOrbs(prev => prev + orbs);\n      setMoney(0);\n      setTotalEarned(0);\n      setCombo(0);\n      setMaxCombo(0);\n      setUnlockedSkills([]);\n      setDragonLevel(1);\n      const initialMaxHp = calculate_monster_hp(100.0, 1.8, 0, false);\n      setMonsterMaxHealth(initialMaxHp);\n      setMonsterHealth(initialMaxHp);\n      setMonsterElement('FIRE');\n      setTotalTaps(0);\n      setCorrectTaps(0);\n      setUnlockedElements(['FIRE', 'WATER']);\n      setEquippedElements(['FIRE', 'WATER']);\n      setUpgrades(gameConfig.upgrades.map(u => ({ ...u, level: 0 })));\n      setCurrentScene('home');\n    }\n  }, [totalEarned]);\n\n  const handleBuyArtifact = useCallback((artifactId, cost) => {\n    if (spiritOrbs >= cost) {\n      setSpiritOrbs(prev => prev - cost);\n      setArtifacts(prev => {\n        const index = prev.findIndex(a => a.id === artifactId);\n        if (index >= 0) {\n          const newArr = [...prev];\n          newArr[index] = { ...newArr[index], level: newArr[index].level + 1 };\n          return newArr;\n        }\n        return [...prev, { id: artifactId, level: 1 }];\n      });\n    }\n  }, [spiritOrbs]);\n\n  const switchWorld = useCallback((worldId) => {\n    const nextIdx = worldProgress[worldId] || 0;\n    setCurrentWorldId(worldId);\n    setStageIndex(nextIdx);\n\n    const worldData = gameConfig.worlds.find(w => w.id === worldId);\n    const newMaxHp = calculate_monster_hp(100.0 * worldData.hpScale, 1.8, nextIdx, nextIdx % 10 === 0);\n    setMonsterMaxHealth(newMaxHp);\n    setMonsterHealth(newMaxHp);\n\n    setCurrentSpell(generateSpell(4, equippedElements));\n    setCurrentProgress(0);\n    setShowWorldSelection(false);\n    triggerDialogue(`${worldData.name} „Å∏Ëª¢Áßª„Åó„Åü„ÄÇ`);\n  }, [worldProgress, equippedElements, triggerDialogue]);\n\n  // startTutorial removed\n\n  const handleTutorialComplete = useCallback(() => {\n    setCompletedTutorials(prev => {\n      if (prev.includes(activeTutorial)) return prev;\n      return [...prev, activeTutorial];\n    });\n    const type = activeTutorial;\n    setActiveTutorial(null);\n    if (type === 'INTRO') {\n      localStorage.setItem('magic_idle_tutorial_completed', 'true');\n      setCurrentScene('battle');\n    }\n  }, [activeTutorial]);\n\n  const handleSplashComplete = useCallback((mode) => {\n    if (mode === 'new') {\n      localStorage.clear();\n      setMoney(0);\n      setTotalEarned(0);\n      setCombo(0);\n      setMaxCombo(0);\n      setUnlockedSkills([]);\n      setCollectedUnits(['n_egg']);\n      setUnitLevels({ 'n_egg': 1 });\n      setDragonLevel(1);\n      const initialMaxHp = calculate_monster_hp(100.0, 1.8, 0, false);\n      setMonsterMaxHealth(initialMaxHp);\n      setMonsterHealth(initialMaxHp);\n      setMonsterElement('FIRE');\n      setTotalTaps(0);\n      setCorrectTaps(0);\n      setUnlockedElements(['FIRE', 'WATER']);\n      setEquippedElements(['FIRE', 'WATER']);\n      setUpgrades(gameConfig.upgrades.map(u => ({ ...u, level: 0 })));\n      setActiveTutorial('INTRO');\n    } else if (localStorage.getItem('magic_idle_tutorial_completed')) {\n      setCurrentScene('home');\n    }\n    setShowSplash(false);\n  }, []);\n\n  // Hub/Battle Tutorial Trigger\n  useEffect(() => {\n    if (showSplash || !isLoaded) return;\n\n    if (currentScene === 'home' && !completedTutorials.includes('HUB')) {\n      setTimeout(() => setActiveTutorial('HUB'), 0);\n    } else if (currentScene === 'battle' && !completedTutorials.includes('BATTLE')) {\n      setTimeout(() => setActiveTutorial('BATTLE'), 0); // Async to avoid render cycle\n    }\n  }, [currentScene, showSplash, isLoaded, completedTutorials]);\n\n  const isFever = combo >= gameConfig.feverTriggerCombo;\n  const accuracy = totalTaps > 0 ? Math.round((correctTaps / totalTaps) * 100) : 100;\n\n  if (showSplash) return <SplashScreen onComplete={handleSplashComplete} />;\n\n  return (\n    <div className={`fixed inset-0 bg-[#0a0a0a] text-white overflow-hidden flex flex-col ${isHaptic ? 'haptic-vibrate' : ''} `}>\n      <CyberpunkBackground combo={combo} worldId={currentWorldId} />\n      {currentScene === 'home' ? (\n        <HomeScreen\n          money={money}\n          totalEarned={totalEarned}\n          dragonLevel={dragonLevel}\n          maxCombo={maxCombo}\n          unlockedAchievements={unlockedAchievements}\n          onOpenAchievements={() => setShowAchievementList(true)}\n          onStartBattle={() => setCurrentScene('battle')}\n          upgrades={upgrades}\n          onPurchase={handlePurchase}\n          unlockedSkills={unlockedSkills}\n          onUnlock={handleSkillUnlock}\n          onOpenSettings={() => setShowSettings(true)}\n          onOpenLore={() => setShowLore(true)}\n          onOpenArtifacts={() => setShowArtifacts(true)}\n          onOpenSkills={() => setShowSkills(true)}\n          onOpenMagicSelection={() => setShowMagicSelection(true)}\n          onOpenWorldSelection={() => setShowWorldSelection(true)}\n          currentWorldId={currentWorldId}\n          collectedUnits={collectedUnits}\n          onPullGacha={handlePullGacha}\n          onSpentMoney={handleSpentMoney}\n          recommendedActionId={currentObjective?.actionId}\n          deckStats={deckStats}\n          artifactStats={artifactStats}\n          magicStats={magicStats}\n        />\n      ) : (\n        <>\n          <div className=\"flex-[45] relative\">\n            <BattleScreen\n              currentSpell={currentSpell}\n              // onSpellComplete removed\n              monsterHealth={monsterHealth}\n              monsterMaxHealth={monsterMaxHealth}\n              bossName={currentBossName}\n              stageData={gameConfig.stages?.[stageIndex] || {}}\n              combo={combo}\n              isFever={isFever}\n              dragonLevel={dragonLevel}\n              chantBreakGauge={chantBreakGauge}\n              isSpellComplete={currentProgress === 0 && currentSpell.length > 0}\n              monsterElement={monsterElement}\n              stageIndex={stageIndex + 1}\n              lastDamage={lastDamage}\n              familiarDialogue={familiarDialogue}\n              isVictorious={isVictorious}\n              currentProgress={currentProgress}\n              keyMapping={KEY_MAPPING}\n              equippedElements={equippedElements}\n              recommendedActionId={currentObjective?.actionId}\n            />\n            <div className=\"absolute top-4 left-4 z-20\">\n              <MoneyDisplay money={money} idleIncome={idleIncome} />\n            </div>\n            <button\n              onClick={() => setActiveTutorial(currentScene === 'home' ? 'HUB' : 'BATTLE')}\n              className=\"absolute top-4 right-4 z-20 w-12 h-12 rounded-full bg-neon-purple/80 hover:bg-neon-purple flex items-center justify-center shadow-lg border-2 border-white/20 transition-all hover:scale-110\"\n            >\n              <HelpCircle size={24} className=\"text-white\" />\n            </button>\n            <button\n              onClick={() => setShowWorldSelection(true)}\n              className=\"absolute top-4 right-20 z-20 w-12 h-12 rounded-full bg-neon-blue/80 hover:bg-neon-blue flex items-center justify-center shadow-lg border-2 border-white/20 transition-all hover:scale-110\"\n            >\n              <Map size={24} className=\"text-white\" />\n            </button>\n          </div>\n          <div className=\"flex-[55] bg-[#1a1a1a] rounded-t-[3rem] shadow-[0_-20px_50px_rgba(0,0,0,0.5)] z-10 flex flex-col p-6\">\n            <div className=\"flex-[1] flex flex-col items-center justify-center relative\">\n              <MagicKeyboard\n                onInput={handleMagicInput}\n                activeElements={equippedElements}\n                keyMapping={KEY_MAPPING}\n              />\n            </div>\n            <div className=\"flex justify-center mt-4\">\n              <button\n                onClick={() => { setCurrentScene('home'); setCombo(0); }}\n                className={`flex items-center gap-2 px-8 py-4 rounded-2xl bg-white/5 text-white/60 hover:bg-white/10 hover:text-white transition-all active:scale-95 border border-white/10 ${currentObjective?.actionId === 'back-to-home' ? 'animate-recommend border-neon-purple text-white bg-neon-purple/20' : ''}`}\n              >\n                <RotateCcw size={18} />\n                <span className=\"text-xs font-black uppercase tracking-widest\">Êã†ÁÇπ„Å∏Êàª„Çã</span>\n              </button>\n            </div>\n          </div>\n        </>\n      )}\n\n      <ObjectiveBanner objective={currentObjective} />\n\n      {showSkills && <SkillTree money={money} unlockedSkills={unlockedSkills} onUnlock={handleSkillUnlock} onClose={() => setShowSkills(false)} />}\n\n      {activeTutorial && (\n        <InteractiveTutorial\n          type={activeTutorial}\n          onComplete={handleTutorialComplete}\n          onSkip={() => setActiveTutorial(null)}\n          currentSpell={currentSpell}\n          currentProgress={currentProgress}\n        />\n      )}\n\n      {offlineEarnings > 0 && (\n        <div className=\"absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in\">\n          <div className=\"bg-[#1a1a1a] p-8 rounded-3xl border border-neon-cyan/50 text-center max-w-sm shadow-[0_0_50px_rgba(0,255,255,0.2)]\">\n            <div className=\"text-4xl mb-4\">üí§</div>\n            <h3 className=\"text-2xl font-black text-white italic mb-2\">„Åä„Åã„Åà„Çä„Å™„Åï„ÅÑÔºÅ</h3>\n            <p className=\"text-3xl font-black text-neon-cyan mb-8\">+{Math.floor(offlineEarnings).toLocaleString()} MP</p>\n            <button onClick={() => setOfflineEarnings(0)} className=\"w-full py-4 bg-neon-cyan text-black font-black uppercase tracking-widest rounded-xl\">ÂõûÂèé„Åô„Çã</button>\n          </div>\n        </div>\n      )}\n      {showResult && <ResultScreen score={totalEarned} maxCombo={maxCombo} accuracy={accuracy} onRestart={() => setShowResult(false)} />}\n      <ChantBreakOverlay isActive={isManualBurst} onComplete={() => { setIsManualBurst(false); setChantBreakGauge(0); }} />\n      {showMagicSelection && <MagicSelectionModal unlockedElements={unlockedElements} equippedElements={equippedElements} onClose={() => setShowMagicSelection(false)} onSave={(newEquipped) => { setEquippedElements(newEquipped); setShowMagicSelection(false); setCurrentSpell(generateSpell(4, newEquipped)); setCurrentProgress(0); }} />}\n      {showWorldSelection && <WorldSelectionModal currentWorldId={currentWorldId} worldProgress={worldProgress} onSelect={switchWorld} onClose={() => setShowWorldSelection(false)} />}\n\n      {showSettings && <SettingsMenu settings={settings} onUpdate={(s) => setSettings(p => ({ ...p, ...s }))} onClose={() => setShowSettings(false)} canRebirth={canRebirth(totalEarned)} nextRebirthOrbs={calculate_rebirth_orbs(totalEarned, 1000000.0, 1000000.0)} totalMoney={totalEarned} onRebirth={handleRebirth} />}\n      {showLore && <LoreTerminal totalEarned={totalEarned} onClose={() => setShowLore(false)} stageIndex={stageIndex + 1} />}\n      {showArtifacts && <ArtifactScreen spiritOrbs={spiritOrbs} artifacts={artifacts} onBuyArtifact={handleBuyArtifact} onClose={() => setShowArtifacts(false)} />}\n\n      {activeAchievementToast && <AchievementToast achievement={activeAchievementToast} onComplete={() => setActiveAchievementToast(null)} />}\n      {showAchievementList && <AchievementList unlockedAchievements={unlockedAchievements} onClose={() => setShowAchievementList(false)} />}\n      {showCriticalOverlay && <CriticalHit onComplete={() => setShowCriticalOverlay(false)} />}\n\n      {showLevelUpEffect && (\n        <div className=\"fixed inset-0 z-[300] pointer-events-none flex items-center justify-center bg-white/10 backdrop-blur-sm animate-in fade-in duration-500\">\n          <div className=\"text-6xl font-black text-yellow-400 italic animate-bounce scale-150 drop-shadow-[0_0_30px_white]\">\n            DRAGON EVOLUTION!\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/AchievementList.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/AchievementToast.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/ArtifactScreen.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/BattleScreen.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/ChantBreakOverlay.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/CriticalHit.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/CyberpunkBackground.jsx","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'react-hooks/purity').","line":13,"column":5,"severity":1,"nodeType":null,"fix":{"range":[421,467],"text":" "}},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  15 |         const data = {\n  16 |             matrix: [...Array(20)].map(() => ({\n> 17 |                 left: Math.random() * 100,\n     |                       ^^^^^^^^^^^^^ Cannot call impure function\n  18 |                 delay: Math.random() * 2,\n  19 |                 duration: 1 + Math.random() * 2,\n  20 |                 chars: [","line":17,"column":23,"nodeType":null,"endLine":17,"endColumn":36},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  16 |             matrix: [...Array(20)].map(() => ({\n  17 |                 left: Math.random() * 100,\n> 18 |                 delay: Math.random() * 2,\n     |                        ^^^^^^^^^^^^^ Cannot call impure function\n  19 |                 duration: 1 + Math.random() * 2,\n  20 |                 chars: [\n  21 |                     String.fromCharCode(0x30A0 + Math.random() * 96),","line":18,"column":24,"nodeType":null,"endLine":18,"endColumn":37},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  17 |                 left: Math.random() * 100,\n  18 |                 delay: Math.random() * 2,\n> 19 |                 duration: 1 + Math.random() * 2,\n     |                               ^^^^^^^^^^^^^ Cannot call impure function\n  20 |                 chars: [\n  21 |                     String.fromCharCode(0x30A0 + Math.random() * 96),\n  22 |                     String.fromCharCode(0x30A0 + Math.random() * 96),","line":19,"column":31,"nodeType":null,"endLine":19,"endColumn":44},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  19 |                 duration: 1 + Math.random() * 2,\n  20 |                 chars: [\n> 21 |                     String.fromCharCode(0x30A0 + Math.random() * 96),\n     |                                                  ^^^^^^^^^^^^^ Cannot call impure function\n  22 |                     String.fromCharCode(0x30A0 + Math.random() * 96),\n  23 |                     String.fromCharCode(0x30A0 + Math.random() * 96)\n  24 |                 ]","line":21,"column":50,"nodeType":null,"endLine":21,"endColumn":63},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  20 |                 chars: [\n  21 |                     String.fromCharCode(0x30A0 + Math.random() * 96),\n> 22 |                     String.fromCharCode(0x30A0 + Math.random() * 96),\n     |                                                  ^^^^^^^^^^^^^ Cannot call impure function\n  23 |                     String.fromCharCode(0x30A0 + Math.random() * 96)\n  24 |                 ]\n  25 |             })),","line":22,"column":50,"nodeType":null,"endLine":22,"endColumn":63},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  21 |                     String.fromCharCode(0x30A0 + Math.random() * 96),\n  22 |                     String.fromCharCode(0x30A0 + Math.random() * 96),\n> 23 |                     String.fromCharCode(0x30A0 + Math.random() * 96)\n     |                                                  ^^^^^^^^^^^^^ Cannot call impure function\n  24 |                 ]\n  25 |             })),\n  26 |             petals: [...Array(15)].map(() => ({","line":23,"column":50,"nodeType":null,"endLine":23,"endColumn":63},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  25 |             })),\n  26 |             petals: [...Array(15)].map(() => ({\n> 27 |                 left: Math.random() * 100,\n     |                       ^^^^^^^^^^^^^ Cannot call impure function\n  28 |                 delay: Math.random() * 5,\n  29 |                 duration: 5 + Math.random() * 5\n  30 |             })),","line":27,"column":23,"nodeType":null,"endLine":27,"endColumn":36},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  26 |             petals: [...Array(15)].map(() => ({\n  27 |                 left: Math.random() * 100,\n> 28 |                 delay: Math.random() * 5,\n     |                        ^^^^^^^^^^^^^ Cannot call impure function\n  29 |                 duration: 5 + Math.random() * 5\n  30 |             })),\n  31 |             stars: [...Array(30)].map(() => ({","line":28,"column":24,"nodeType":null,"endLine":28,"endColumn":37},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  27 |                 left: Math.random() * 100,\n  28 |                 delay: Math.random() * 5,\n> 29 |                 duration: 5 + Math.random() * 5\n     |                               ^^^^^^^^^^^^^ Cannot call impure function\n  30 |             })),\n  31 |             stars: [...Array(30)].map(() => ({\n  32 |                 left: Math.random() * 100,","line":29,"column":31,"nodeType":null,"endLine":29,"endColumn":44},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  30 |             })),\n  31 |             stars: [...Array(30)].map(() => ({\n> 32 |                 left: Math.random() * 100,\n     |                       ^^^^^^^^^^^^^ Cannot call impure function\n  33 |                 top: Math.random() * 100,\n  34 |                 delay: Math.random() * 3\n  35 |             }))","line":32,"column":23,"nodeType":null,"endLine":32,"endColumn":36},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  31 |             stars: [...Array(30)].map(() => ({\n  32 |                 left: Math.random() * 100,\n> 33 |                 top: Math.random() * 100,\n     |                      ^^^^^^^^^^^^^ Cannot call impure function\n  34 |                 delay: Math.random() * 3\n  35 |             }))\n  36 |         };","line":33,"column":22,"nodeType":null,"endLine":33,"endColumn":35},{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Math.random` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  32 |                 left: Math.random() * 100,\n  33 |                 top: Math.random() * 100,\n> 34 |                 delay: Math.random() * 3\n     |                        ^^^^^^^^^^^^^ Cannot call impure function\n  35 |             }))\n  36 |         };\n  37 |         return data;","line":34,"column":24,"nodeType":null,"endLine":34,"endColumn":37}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import React, { useMemo } from 'react';\n\n// Cyberpunk Background Effects Component\nconst CyberpunkBackground = ({ combo, worldId = 'GENESIS' }) => {\n    // Determine neon edge glow intensity based on combo\n    const getNeonClass = () => {\n        if (combo >= 25) return 'combo-extreme';\n        if (combo >= 15) return 'combo-high';\n        if (combo >= 5) return 'combo-medium';\n        return 'combo-low';\n    };\n\n    // eslint-disable-next-line react-hooks/purity\n    const weatherData = useMemo(() => {\n        const data = {\n            matrix: [...Array(20)].map(() => ({\n                left: Math.random() * 100,\n                delay: Math.random() * 2,\n                duration: 1 + Math.random() * 2,\n                chars: [\n                    String.fromCharCode(0x30A0 + Math.random() * 96),\n                    String.fromCharCode(0x30A0 + Math.random() * 96),\n                    String.fromCharCode(0x30A0 + Math.random() * 96)\n                ]\n            })),\n            petals: [...Array(15)].map(() => ({\n                left: Math.random() * 100,\n                delay: Math.random() * 5,\n                duration: 5 + Math.random() * 5\n            })),\n            stars: [...Array(30)].map(() => ({\n                left: Math.random() * 100,\n                top: Math.random() * 100,\n                delay: Math.random() * 3\n            }))\n        };\n        return data;\n    }, []);\n\n    const WeatherEffect = useMemo(() => {\n        switch (worldId) {\n            case 'CYBERIA':\n                return (\n                    <div className=\"absolute inset-0 overflow-hidden opacity-30\">\n                        {weatherData.matrix.map((item, i) => (\n                            <div\n                                key={i}\n                                className=\"absolute text-matrix-green font-mono text-xs animate-digital-rain\"\n                                style={{\n                                    left: `${item.left}%`,\n                                    animationDelay: `${item.delay}s`,\n                                    animationDuration: `${item.duration}s`\n                                }}\n                            >\n                                {item.chars[0]}\n                                <br />\n                                {item.chars[1]}\n                                <br />\n                                {item.chars[2]}\n                            </div>\n                        ))}\n                    </div>\n                );\n            case 'GENESIS':\n                return (\n                    <div className=\"absolute inset-0 overflow-hidden opacity-40\">\n                        {weatherData.petals.map((item, i) => (\n                            <div\n                                key={i}\n                                className=\"absolute w-4 h-4 bg-pink-300/60 rounded-full animate-petal blur-[1px]\"\n                                style={{\n                                    left: `${item.left}%`,\n                                    top: `-5%`,\n                                    animationDelay: `${item.delay}s`,\n                                    animationDuration: `${item.duration}s`\n                                }}\n                            />\n                        ))}\n                    </div>\n                );\n            case 'ETERNITY':\n                return (\n                    <div className=\"absolute inset-0 overflow-hidden\">\n                        <div className=\"absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-indigo-900/40 via-transparent to-transparent animate-pulse\" />\n                        {weatherData.stars.map((item, i) => (\n                            <div\n                                key={i}\n                                className=\"absolute w-1 h-1 bg-white rounded-full animate-pulse shadow-[0_0_10px_white]\"\n                                style={{\n                                    left: `${item.left}%`,\n                                    top: `${item.top}%`,\n                                    animationDelay: `${item.delay}s`\n                                }}\n                            />\n                        ))}\n                    </div>\n                );\n            case 'LEGEND':\n                return (\n                    <div className=\"absolute inset-0 overflow-hidden\">\n                        <div className=\"absolute inset-0 bg-gradient-to-br from-yellow-500/10 via-transparent to-orange-500/10\" />\n                        {[...Array(5)].map((_, i) => (\n                            <div\n                                key={i}\n                                className=\"absolute w-[200%] h-32 bg-gradient-to-r from-transparent via-yellow-200/5 to-transparent -rotate-45 animate-scan\"\n                                style={{ top: `${i * 25}%`, animationDelay: `${i * 0.5}s` }}\n                            />\n                        ))}\n                    </div>\n                );\n            default:\n                return null;\n        }\n    }, [worldId, weatherData.matrix, weatherData.petals, weatherData.stars]);\n\n    return (\n        <div className=\"fixed inset-0 pointer-events-none z-0 overflow-hidden bg-slate-950\">\n            {/* Base grid background */}\n            <div className=\"absolute inset-0 bg-[linear-gradient(to_right,#0f172a_1px,transparent_1px),linear-gradient(to_bottom,#0f172a_1px,transparent_1px)] bg-[size:4rem_4rem] [mask-image:radial-gradient(ellipse_60%_50%_at_50%_0%,#000_70%,transparent_100%)] opacity-20\" />\n\n            {/* Weather Effects */}\n            {WeatherEffect}\n\n            {/* Dynamic scanning line */}\n            <div className=\"absolute inset-0 bg-gradient-to-b from-transparent via-blue-500/10 to-transparent h-[200%] animate-scan pointer-events-none\" />\n\n            {/* Static/Noise overlay */}\n            <div className=\"noise-overlay opacity-30\" />\n\n            {/* Neon edge glow based on combo */}\n            {combo > 0 && (\n                <div className={`neon-edge-glow ${getNeonClass()}`} />\n            )}\n\n            {/* Bottom glow */}\n            <div className=\"absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-blue-900/20 to-transparent\" />\n        </div>\n    );\n};\n\nexport default CyberpunkBackground;\n","usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/DragonFamiliar.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/GachaScreen.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/HomeScreen.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/InteractiveTutorial.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/LoreTerminal.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/MagicKeyboard.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/MagicSelectionModal.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/MoneyDisplay.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/ObjectiveBanner.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/ParticleEffect.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/PassiveStatusCard.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/ProgressBar.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/ResultScreen.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/SettingsMenu.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/Shop.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/SkillTree.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/SplashScreen.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/UnitList.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/components/WorldSelectionModal.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/data/achievementData.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/data/artifactData.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/data/storyData.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/data/tutorialContent.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/data/unitData.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/hooks/useIdleIncome.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/hooks/useScreenShake.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/main.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/utils/AudioManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/utils/gachaSystem.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/utils/gameConfig.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/utils/rebirthSystem.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/utils/wordList.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/src/wasm_pkg/magic_engine.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/iwatakoumei/.gemini/antigravity/scratch/typing-idle-game/vite.config.js","messages":[],"suppressedMessages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":9,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":32,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
